<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>双人蛇堵棋</title>
<style>
  body { font-family: sans-serif; text-align: center; }
  #board { border: 1px solid #333; display: block; margin: 20px auto; background-color: #f5d6a0; }
  #message { margin-top: 10px; font-weight: bold; }
  #controls { margin-top: 10px; }
  button { margin: 0 5px; }
  .overlay { position: fixed; top:0; left:0; right:0; bottom:0; background: rgba(0,0,0,0.8); color:#fff; display:flex; align-items:center; justify-content:center; flex-direction:column; }
  .hidden { display:none; }
  #demoBoard { width:150px; height:150px; margin:20px auto; position:relative; background:#f5d6a0; border:1px solid #333; }
  .stone { width:18px; height:18px; border-radius:50%; position:absolute; }
  .black { background:#000; }
  .white { background:#fff; border:1px solid #000; }
  @keyframes demo-play {
    0% {transform: scale(0);}
    20% {transform: scale(1);}
    40% {transform: scale(1);}
    60% {transform: scale(1);}
    80% {transform: scale(1);}
    100%{transform: scale(1);}
  }
  .animate { animation: demo-play 2s forwards; }
</style>
</head>
<body>
<canvas id="board" width="600" height="600"></canvas>
<div id="message"></div>
<div id="controls">
  <button id="restart">重新开始</button>
</div>
<div id="instructions" class="overlay">
  <h1>蛇堵棋规则</h1>
  <p>两名玩家依次在棋盘的<strong>星位</strong>开始，下子形成自己的蛇。每回合只能在自己蛇的首尾相邻处延长一格。</p>
  <p>若蛇的一端被堵死，可选择截断并清除该堵死部分；当一条蛇的两端都被堵死时，对手获胜。</p>
  <div id="demoBoard">
    <div class="stone black animate" style="top:60px;left:60px;animation-delay:0.2s"></div>
    <div class="stone white animate" style="top:60px;left:90px;animation-delay:0.6s"></div>
    <div class="stone black animate" style="top:90px;left:60px;animation-delay:1s"></div>
    <div class="stone white animate" style="top:90px;left:90px;animation-delay:1.4s"></div>
  </div>
  <button id="startGame">开始游戏</button>
</div>
<script>
const boardSize = 19;
const cellSize = 30;
const padding = cellSize;
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
canvas.width = canvas.height = padding * 2 + cellSize * (boardSize - 1);
let current = 'black';
const snakes = {black: [], white: []};
const occupied = {};
const messageEl = document.getElementById('message');

function drawBoard(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle = '#333';
  for(let i=0;i<boardSize;i++){
    const pos = padding + i*cellSize;
    ctx.beginPath();
    ctx.moveTo(padding,pos); ctx.lineTo(canvas.width-padding,pos); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(pos,padding); ctx.lineTo(pos,canvas.height-padding); ctx.stroke();
  }
  // star points
  const stars = [3,9,15];
  stars.forEach(x=>{
    stars.forEach(y=>{
      ctx.beginPath();
      ctx.arc(padding+x*cellSize,padding+y*cellSize,4,0,Math.PI*2);
      ctx.fill();
    });
  });
  // draw stones
  Object.entries(snakes).forEach(([color,list])=>{
    list.forEach(pt=>drawStone(pt.x,pt.y,color));
  });
}

function drawStone(x,y,color){
  ctx.beginPath();
  ctx.fillStyle = color==='black'?'#000':'#fff';
  ctx.strokeStyle = '#000';
  ctx.arc(padding+x*cellSize,padding+y*cellSize,12,0,Math.PI*2);
  ctx.fill();
  ctx.stroke();
}

function posKey(x,y){ return x+','+y; }

canvas.addEventListener('click', e=>{
  const rect = canvas.getBoundingClientRect();
  const x = Math.round((e.clientX - rect.left - padding)/cellSize);
  const y = Math.round((e.clientY - rect.top - padding)/cellSize);
  if(x<0||x>=boardSize||y<0||y>=boardSize) return;
  const key = posKey(x,y);
  if(occupied[key]) return;
  const mySnake = snakes[current];
  if(mySnake.length===0){
    // must be star point
    if(!isStar(x,y)) return;
    place(x,y);
  }else{
    const head = mySnake[0];
    const tail = mySnake[mySnake.length-1];
    if(adjacent(x,y,head) || adjacent(x,y,tail)){
      if(adjacent(x,y,head)){
        mySnake.unshift({x,y});
      }else{
        mySnake.push({x,y});
      }
      occupied[key] = current;
      drawBoard();
      switchPlayer();
      return;
    }else{
      return;
    }
  }
  drawBoard();
  switchPlayer();
});

function isStar(x,y){
  const starCoords = [3,9,15];
  return starCoords.includes(x) && starCoords.includes(y);
}

function adjacent(x,y,p){
  return Math.abs(x-p.x)+Math.abs(y-p.y)===1;
}

function place(x,y){
  snakes[current].push({x,y});
  occupied[posKey(x,y)] = current;
}

function switchPlayer(){
  if(checkWin()) return;
  current = current==='black'?'white':'black';
  messageEl.textContent = (current==='black'?'黑':'白')+"方行动";
}

function neighborsFree(pt){
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  return dirs.some(d=>{
    const nx=pt.x+d[0], ny=pt.y+d[1];
    if(nx<0||ny<0||nx>=boardSize||ny>=boardSize) return false;
    return !occupied[posKey(nx,ny)];
  });
}

function checkWin(){
  const opp = current==='black'?'white':'black';
  const s = snakes[opp];
  if(s.length===0) return false;
  const headFree = neighborsFree(s[0]);
  const tailFree = neighborsFree(s[s.length-1]);
  if(!headFree && !tailFree){
    messageEl.textContent = (current==='black'?'黑':'白')+"方获胜！";
    canvas.removeEventListener('click',arguments.callee);
    return true;
  }
  return false;
}

document.getElementById('restart').onclick = ()=>location.reload();

document.getElementById('startGame').onclick = ()=>{
  document.getElementById('instructions').classList.add('hidden');
  drawBoard();
  messageEl.textContent = '黑方行动';
};
</script>
</body>
</html>
